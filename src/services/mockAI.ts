import type { NoteStructure, ToolType } from '../types.ts';
import Tesseract from 'tesseract.js';

/**
 * MOCK AI SERVICE
 * 
 * This service simulates AI responses. In a real application, 
 * you would replace these `setTimeout` calls with `fetch` requests 
 * to your backend or calls to the Google Gemini API.
 * 
 * To integrate Gemini:
 * 1. Install @google/genai
 * 2. Import { GoogleGenAI } from "@google/genai"
 * 3. Initialize with process.env.API_KEY
 */

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const mockSummarizeText = async (text: string): Promise<string> => {
  await delay(1500); // Simulate network/processing latency
  
  if (text.length < 20) throw new Error("Text is too short to summarize.");

  return `Here is a concise summary of your text:\n\nThe input text discusses key themes regarding "${text.substring(0, 15)}...". The main points are:\n• The central argument focuses on the importance of efficiency.\n• Secondary analysis suggests a need for robust error handling.\n• Conclusion emphasizes user experience as a priority.\n\n(Generated by TattvaAI Mock Engine)`;
};

export const mockYouTubeSummary = async (url: string): Promise<{ title: string; summary: string; keyLearnings: string[] }> => {
  await delay(2000);
  
  // Basic validation
  const videoIdMatch = url.match(/(?:youtu\.be\/|youtube\.com(?:\/embed\/|\/v\/|\/watch\?v=|\/user\/\S+|\/ytscreeningroom\?v=))([\w-]{10,12})\b/);
  
  const title = videoIdMatch ? `Video Analysis: ${videoIdMatch[1]}` : "Understanding Modern AI Architectures";

  return {
    title,
    summary: "This video provides a comprehensive overview of neural network architectures. The speaker breaks down the evolution from RNNs to Transformers, explaining the attention mechanism in detail.",
    keyLearnings: [
      "Transformers process data in parallel, unlike RNNs.",
      "Self-attention allows the model to weigh the importance of different words.",
      "Fine-tuning pretrained models is more efficient than training from scratch."
    ]
  };
};

export const mockOCR = async (file: File): Promise<string> => {
  try {
    // Attempt real client-side OCR
    const result = await Tesseract.recognize(file, 'eng', {
      logger: (m) => console.log('OCR Log:', m) // Optional logger
    });
    
    if (!result.data.text.trim()) {
      return "No text detected in the image.";
    }
    
    return result.data.text;
  } catch (error) {
    console.error("OCR Error:", error);
    // Fallback if Tesseract fails (e.g. in some restricted environments)
    await delay(2000);
    return `[Fallback Mode] We encountered an issue running the OCR engine in this environment.\n\nHere is a simulated extraction:\n\nProject Tattva Meeting Notes\nDate: Oct 24, 2023\n\nAgenda:\n1. Review Q3 Goals\n2. Discuss UI Component Library`;
  }
};

export const mockImageToNotes = async (file: File): Promise<NoteStructure> => {
  // NOTE: High-quality "Image to Structured Notes" requires a Vision-Language Model (like GPT-4V or Gemini Pro Vision).
  // Since we cannot use API keys in this template, this remains a mock.
  
  await delay(3000);
  return {
    heading: "Introduction to Thermodynamics (Demo)",
    subpoints: [
      "The First Law: Energy cannot be created or destroyed.",
      "The Second Law: Entropy of an isolated system always increases.",
      "Heat transfer occurs via conduction, convection, and radiation."
    ],
    keyIdeas: [
      "Energy conservation is fundamental.",
      "Efficiency of heat engines is limited by Carnot's theorem."
    ],
    definitions: [
      { term: "Entropy", definition: "A measure of the disorder of a system." },
      { term: "Enthalpy", definition: "Total heat content of a system." }
    ]
  };
};

export const mockChatQuery = async (query: string): Promise<string> => {
  await delay(1000);
  return `Based on the video context, the answer to "${query}" involves understanding the balance between model size and inference latency. The speaker recommends starting with distilled models for edge deployment.`;
};